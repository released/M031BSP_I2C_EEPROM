; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\main.o --asm_dir=.\lst\ --list_dir=.\lst\ --depend=.\obj\main.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I..\..\..\Library\CMSIS\Include -I..\..\..\Library\Device\Nuvoton\M031\Include -I..\..\..\Library\StdDriver\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=526 --omf_browse=.\obj\main.crf ..\main.c]
                          THUMB

                          AREA ||i.EEPROM_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  EEPROM_Process PROC
;;;376    
;;;377    void EEPROM_Process(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;378    {
000002  b087              SUB      sp,sp,#0x1c
;;;379    	uint8_t u8SlaveAddr = EEPROM_SLAVE_ADDR >>1;
000004  2050              MOVS     r0,#0x50
;;;380    	uint16_t i = 0;
;;;381    	uint8_t value = 0;
000006  9005              STR      r0,[sp,#0x14]
000008  2400              MOVS     r4,#0                 ;380
00000a  4669              MOV      r1,sp
00000c  700c              STRB     r4,[r1,#0]
;;;382    	static uint8_t addr = 0;
;;;383    	static uint8_t temp = 0;
;;;384    	const uint8_t data1[16] = 
00000e  a046              ADR      r0,|L1.296|
000010  c80f              LDM      r0,{r0-r3}
;;;385    	{
;;;386    		0x23 , 0x16 , 0x80 , 0x49 , 0x56 , 0x30 , 0x17 , 0x22 ,
;;;387    		0x33 , 0x46 , 0x55 , 0x27 , 0x39 , 0x48 , 0x57 , 0x60			
;;;388    	};
;;;389    
;;;390    	if (is_flag_set(flag_Dump))
000012  ae01              ADD      r6,sp,#4
000014  c60f              STM      r6!,{r0-r3}
000016  4d48              LDR      r5,|L1.312|
000018  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
;;;391    	{
;;;392    		set_flag(flag_Dump , DISABLE);
;;;393    		
;;;394    		printf("dump EEPROM\r\n");
;;;395    		for (i = 0 ; i < 0x100 ; i++ )
;;;396    		{
;;;397    			I2Cx_ReadMultiFromSlaveIRQ(u8SlaveAddr , i , &value , 1);
00001a  2601              MOVS     r6,#1
00001c  0780              LSLS     r0,r0,#30             ;390
00001e  2800              CMP      r0,#0                 ;390
000020  da1c              BGE      |L1.92|
000022  68e8              LDR      r0,[r5,#0xc]          ;392  ; BitFlag
000024  2102              MOVS     r1,#2                 ;392
000026  4388              BICS     r0,r0,r1              ;392
000028  60e8              STR      r0,[r5,#0xc]          ;392  ; BitFlag
00002a  a044              ADR      r0,|L1.316|
00002c  f7fffffe          BL       __2printf
;;;398    			printf("0x%2X," ,value);
;;;399    
;;;400    			if ((i+1)%8 ==0)
000030  0777              LSLS     r7,r6,#29
                  |L1.50|
000032  b2e1              UXTB     r1,r4                 ;397
000034  2301              MOVS     r3,#1                 ;397
000036  466a              MOV      r2,sp                 ;397
000038  9805              LDR      r0,[sp,#0x14]         ;397
00003a  f7fffffe          BL       I2Cx_ReadMultiFromSlaveIRQ
00003e  4668              MOV      r0,sp                 ;398
000040  7801              LDRB     r1,[r0,#0]            ;398
000042  a042              ADR      r0,|L1.332|
000044  f7fffffe          BL       __2printf
000048  0760              LSLS     r0,r4,#29
00004a  42f8              CMN      r0,r7
00004c  d102              BNE      |L1.84|
;;;401    	        {
;;;402    	            printf("\r\n");
00004e  a041              ADR      r0,|L1.340|
000050  f7fffffe          BL       __2printf
                  |L1.84|
000054  1c64              ADDS     r4,r4,#1
000056  b2a4              UXTH     r4,r4                 ;395
000058  2cff              CMP      r4,#0xff              ;395
00005a  d9ea              BLS      |L1.50|
                  |L1.92|
;;;403    	        }
;;;404    		}
;;;405    	}
;;;406    
;;;407    	if (is_flag_set(flag_WriteAddr))		// fix vaule , to incr address
00005c  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
00005e  0700              LSLS     r0,r0,#28
000060  d513              BPL      |L1.138|
;;;408    	{
;;;409    		set_flag(flag_WriteAddr , DISABLE);
000062  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
000064  2108              MOVS     r1,#8
000066  4388              BICS     r0,r0,r1
000068  60e8              STR      r0,[r5,#0xc]  ; BitFlag
;;;410    	
;;;411    		value = 0x01;
00006a  4668              MOV      r0,sp
00006c  7006              STRB     r6,[r0,#0]
;;;412    		I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , addr , &value , 1);
00006e  2301              MOVS     r3,#1
000070  466a              MOV      r2,sp
000072  7869              LDRB     r1,[r5,#1]  ; addr
000074  9805              LDR      r0,[sp,#0x14]
000076  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;413    		printf("WR : 0x%2X : 0x%2X \r\n" , addr++ , value);
00007a  7869              LDRB     r1,[r5,#1]  ; addr
00007c  1c48              ADDS     r0,r1,#1
00007e  7068              STRB     r0,[r5,#1]
000080  4668              MOV      r0,sp
000082  7802              LDRB     r2,[r0,#0]
000084  a034              ADR      r0,|L1.344|
000086  f7fffffe          BL       __2printf
                  |L1.138|
;;;414    	}
;;;415    
;;;416    	if (is_flag_set(flag_WriteData))		// incr vaule , to fix address
00008a  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
00008c  06c0              LSLS     r0,r0,#27
00008e  d515              BPL      |L1.188|
;;;417    	{
;;;418    		set_flag(flag_WriteData , DISABLE);
000090  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
000092  2110              MOVS     r1,#0x10
000094  4388              BICS     r0,r0,r1
000096  60e8              STR      r0,[r5,#0xc]  ; BitFlag
;;;419    	
;;;420    		value = temp++;
000098  78a8              LDRB     r0,[r5,#2]  ; temp
00009a  466a              MOV      r2,sp
00009c  7010              STRB     r0,[r2,#0]
00009e  1c40              ADDS     r0,r0,#1
0000a0  70a8              STRB     r0,[r5,#2]
;;;421    		addr = 0x10;
0000a2  7069              STRB     r1,[r5,#1]
;;;422    		I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , addr , &value , 1);
0000a4  2301              MOVS     r3,#1
0000a6  9805              LDR      r0,[sp,#0x14]
0000a8  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;423    		printf("WR : 0x%2X : 0x%2X \r\n" , addr++ , value);	
0000ac  7869              LDRB     r1,[r5,#1]  ; addr
0000ae  466a              MOV      r2,sp
0000b0  1c48              ADDS     r0,r1,#1
0000b2  7068              STRB     r0,[r5,#1]
0000b4  7812              LDRB     r2,[r2,#0]
0000b6  a028              ADR      r0,|L1.344|
0000b8  f7fffffe          BL       __2printf
                  |L1.188|
;;;424    	}
;;;425    
;;;426    	if (is_flag_set(flag_WriteData1))
0000bc  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
0000be  0680              LSLS     r0,r0,#26
0000c0  d518              BPL      |L1.244|
;;;427    	{
;;;428    		set_flag(flag_WriteData1 , DISABLE);
0000c2  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
0000c4  2120              MOVS     r1,#0x20
0000c6  4388              BICS     r0,r0,r1
0000c8  60e8              STR      r0,[r5,#0xc]  ; BitFlag
;;;429    
;;;430    		addr = 0x40;
0000ca  2040              MOVS     r0,#0x40
0000cc  7068              STRB     r0,[r5,#1]
;;;431    		for ( i = 0 ; i < 16; i++)
0000ce  2400              MOVS     r4,#0
0000d0  ae01              ADD      r6,sp,#4              ;384
                  |L1.210|
;;;432    		{
;;;433    			I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , addr++ , (uint8_t *) &data1[i] , 1);
0000d2  7869              LDRB     r1,[r5,#1]  ; addr
0000d4  1932              ADDS     r2,r6,r4
0000d6  1c48              ADDS     r0,r1,#1
0000d8  7068              STRB     r0,[r5,#1]
0000da  2301              MOVS     r3,#1
0000dc  9805              LDR      r0,[sp,#0x14]
0000de  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;434    //			CLK_SysTickDelay(1000);
;;;435    			printf("WR : 0x%2X : 0x%2X \r\n" , addr , data1[i]);	
0000e2  5d32              LDRB     r2,[r6,r4]
0000e4  7869              LDRB     r1,[r5,#1]  ; addr
0000e6  a01c              ADR      r0,|L1.344|
0000e8  f7fffffe          BL       __2printf
0000ec  1c64              ADDS     r4,r4,#1
0000ee  b2a4              UXTH     r4,r4                 ;431
0000f0  2c10              CMP      r4,#0x10              ;431
0000f2  d3ee              BCC      |L1.210|
                  |L1.244|
;;;436    			
;;;437    		}	
;;;438    		
;;;439    	}
;;;440    	
;;;441    
;;;442    
;;;443    	if (is_flag_set(flag_Erase))
0000f4  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
0000f6  07c0              LSLS     r0,r0,#31
0000f8  d014              BEQ      |L1.292|
;;;444    	{
;;;445    		set_flag(flag_Erase , DISABLE);
0000fa  68e8              LDR      r0,[r5,#0xc]  ; BitFlag
0000fc  0840              LSRS     r0,r0,#1
0000fe  0040              LSLS     r0,r0,#1
000100  60e8              STR      r0,[r5,#0xc]  ; BitFlag
;;;446    	
;;;447    		printf("clear EEPROM\r\n");
000102  a01b              ADR      r0,|L1.368|
000104  f7fffffe          BL       __2printf
;;;448    		value = 0xFF;
000108  20ff              MOVS     r0,#0xff
00010a  4669              MOV      r1,sp
00010c  7008              STRB     r0,[r1,#0]
;;;449    		for (i = 0 ; i < 0x100 ; i++ )
00010e  2400              MOVS     r4,#0
                  |L1.272|
;;;450    		{
;;;451    			I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , i , &value , 1);		
000110  b2e1              UXTB     r1,r4
000112  2301              MOVS     r3,#1
000114  466a              MOV      r2,sp
000116  9805              LDR      r0,[sp,#0x14]
000118  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
00011c  1c64              ADDS     r4,r4,#1
00011e  b2a4              UXTH     r4,r4                 ;449
000120  2cff              CMP      r4,#0xff              ;449
000122  d9f5              BLS      |L1.272|
                  |L1.292|
;;;452    		}
;;;453    
;;;454    	}
;;;455    	
;;;456    }
000124  b007              ADD      sp,sp,#0x1c
000126  bdf0              POP      {r4-r7,pc}
;;;457    
                          ENDP

                  |L1.296|
000128  23168049          DCB      "#",22,128,"IV0",23,"""3FU'9HW`"
00012c  56301722
000130  33465527
000134  39485760
                  |L1.312|
                          DCD      ||.data||
                  |L1.316|
00013c  64756d70          DCB      "dump EEPROM\r\n",0
000140  20454550
000144  524f4d0d
000148  0a00    
00014a  00                DCB      0
00014b  00                DCB      0
                  |L1.332|
00014c  30782532          DCB      "0x%2X,",0
000150  582c00  
000153  00                DCB      0
                  |L1.340|
000154  0d0a00            DCB      "\r\n",0
000157  00                DCB      0
                  |L1.344|
000158  5752203a          DCB      "WR : 0x%2X : 0x%2X \r\n",0
00015c  20307825
000160  3258203a
000164  20307825
000168  3258200d
00016c  0a00    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L1.368|
000170  636c6561          DCB      "clear EEPROM\r\n",0
000174  72204545
000178  50524f4d
00017c  0d0a00  
00017f  00                DCB      0

                          AREA ||i.EEPROM_TEST||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  EEPROM_TEST PROC
;;;326    
;;;327    void EEPROM_TEST(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;328    {
;;;329    	uint8_t value = 0;
000002  2000              MOVS     r0,#0
000004  4669              MOV      r1,sp
000006  7008              STRB     r0,[r1,#0]
;;;330    	uint16_t i = 0 ;
000008  4604              MOV      r4,r0
;;;331    	uint8_t u8SlaveAddr = EEPROM_SLAVE_ADDR >>1;
00000a  2550              MOVS     r5,#0x50
;;;332    
;;;333    	#if 1	//clear EEPROM
;;;334    	printf("clear EEPROM\r\n");	
00000c  a031              ADR      r0,|L2.212|
00000e  f7fffffe          BL       __2printf
;;;335    	value = 0xFF;
000012  20ff              MOVS     r0,#0xff
000014  4669              MOV      r1,sp
000016  7008              STRB     r0,[r1,#0]
                  |L2.24|
;;;336    	for (i = 0 ; i < 0x100 ; i++ )
;;;337    	{
;;;338    		I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , i , &value , 1);		
000018  b2e1              UXTB     r1,r4
00001a  2301              MOVS     r3,#1
00001c  466a              MOV      r2,sp
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
000024  1c64              ADDS     r4,r4,#1
000026  b2a4              UXTH     r4,r4                 ;336
000028  2cff              CMP      r4,#0xff              ;336
00002a  d9f5              BLS      |L2.24|
;;;339    	}
;;;340    
;;;341    	#endif
;;;342    
;;;343    	value = 0xF4;
00002c  20f4              MOVS     r0,#0xf4
00002e  4669              MOV      r1,sp
000030  7008              STRB     r0,[r1,#0]
;;;344    	I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , 0x00 , &value , 1);
000032  2301              MOVS     r3,#1
000034  466a              MOV      r2,sp
000036  2100              MOVS     r1,#0
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;345    	printf("WR : 0x01 : 0x%2X \r\n" , value);
00003e  4669              MOV      r1,sp
000040  7809              LDRB     r1,[r1,#0]
000042  a028              ADR      r0,|L2.228|
000044  f7fffffe          BL       __2printf
;;;346    
;;;347    	value = 0x12;
000048  2012              MOVS     r0,#0x12
00004a  4669              MOV      r1,sp
00004c  7008              STRB     r0,[r1,#0]
;;;348    	I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , 0x01 , &value , 1);
00004e  2301              MOVS     r3,#1
000050  466a              MOV      r2,sp
000052  4619              MOV      r1,r3
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;349    	printf("WR : 0x01 : 0x%2X \r\n" , value);
00005a  4669              MOV      r1,sp
00005c  7809              LDRB     r1,[r1,#0]
00005e  a021              ADR      r0,|L2.228|
000060  f7fffffe          BL       __2printf
;;;350    	
;;;351    	value = 0x34;
000064  2034              MOVS     r0,#0x34
000066  4669              MOV      r1,sp
000068  7008              STRB     r0,[r1,#0]
;;;352    	I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , 0x02 , &value , 1);
00006a  2301              MOVS     r3,#1
00006c  466a              MOV      r2,sp
00006e  2102              MOVS     r1,#2
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;353    	printf("WR : 0x02 : 0x%2X \r\n" , value);
000076  4669              MOV      r1,sp
000078  7809              LDRB     r1,[r1,#0]
00007a  a020              ADR      r0,|L2.252|
00007c  f7fffffe          BL       __2printf
;;;354    	
;;;355    	value = 0x56;
000080  2056              MOVS     r0,#0x56
000082  4669              MOV      r1,sp
000084  7008              STRB     r0,[r1,#0]
;;;356    	I2Cx_WriteMultiToSlaveIRQ(u8SlaveAddr , 0x03 , &value , 1);
000086  2301              MOVS     r3,#1
000088  466a              MOV      r2,sp
00008a  2103              MOVS     r1,#3
00008c  4628              MOV      r0,r5
00008e  f7fffffe          BL       I2Cx_WriteMultiToSlaveIRQ
;;;357    	printf("WR : 0x03 : 0x%2X \r\n" , value);
000092  4669              MOV      r1,sp
000094  7809              LDRB     r1,[r1,#0]
000096  a01f              ADR      r0,|L2.276|
000098  f7fffffe          BL       __2printf
;;;358    
;;;359    	#if 1	//dump EEPROM
;;;360    	printf("dump EEPROM\r\n");	
00009c  a023              ADR      r0,|L2.300|
00009e  f7fffffe          BL       __2printf
;;;361    	for (i = 0 ; i < 0x100 ; i++ )
0000a2  2400              MOVS     r4,#0
;;;362    	{
;;;363    		I2Cx_ReadMultiFromSlaveIRQ(u8SlaveAddr , i , &value , 1);
;;;364    		printf("0x%2X," ,value);
;;;365    
;;;366    		if ((i+1)%8 ==0)
0000a4  2601              MOVS     r6,#1
0000a6  0776              LSLS     r6,r6,#29
                  |L2.168|
0000a8  b2e1              UXTB     r1,r4                 ;363
0000aa  2301              MOVS     r3,#1                 ;363
0000ac  466a              MOV      r2,sp                 ;363
0000ae  4628              MOV      r0,r5                 ;363
0000b0  f7fffffe          BL       I2Cx_ReadMultiFromSlaveIRQ
0000b4  4668              MOV      r0,sp                 ;364
0000b6  7801              LDRB     r1,[r0,#0]            ;364
0000b8  a020              ADR      r0,|L2.316|
0000ba  f7fffffe          BL       __2printf
0000be  0760              LSLS     r0,r4,#29
0000c0  42f0              CMN      r0,r6
0000c2  d102              BNE      |L2.202|
;;;367            {
;;;368                printf("\r\n");
0000c4  a006              ADR      r0,|L2.224|
0000c6  f7fffffe          BL       __2printf
                  |L2.202|
0000ca  1c64              ADDS     r4,r4,#1
0000cc  b2a4              UXTH     r4,r4                 ;361
0000ce  2cff              CMP      r4,#0xff              ;361
0000d0  d9ea              BLS      |L2.168|
;;;369            }
;;;370    	}
;;;371    
;;;372    	#endif
;;;373    
;;;374    	
;;;375    }
0000d2  bdf8              POP      {r3-r7,pc}
;;;376    
                          ENDP

                  |L2.212|
0000d4  636c6561          DCB      "clear EEPROM"
0000d8  72204545
0000dc  50524f4d
                  |L2.224|
0000e0  0d0a00            DCB      "\r\n",0
0000e3  00                DCB      0
                  |L2.228|
0000e4  5752203a          DCB      "WR : 0x01 : 0x%2X \r\n",0
0000e8  20307830
0000ec  31203a20
0000f0  30782532
0000f4  58200d0a
0000f8  00      
0000f9  00                DCB      0
0000fa  00                DCB      0
0000fb  00                DCB      0
                  |L2.252|
0000fc  5752203a          DCB      "WR : 0x02 : 0x%2X \r\n",0
000100  20307830
000104  32203a20
000108  30782532
00010c  58200d0a
000110  00      
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
                  |L2.276|
000114  5752203a          DCB      "WR : 0x03 : 0x%2X \r\n",0
000118  20307830
00011c  33203a20
000120  30782532
000124  58200d0a
000128  00      
000129  00                DCB      0
00012a  00                DCB      0
00012b  00                DCB      0
                  |L2.300|
00012c  64756d70          DCB      "dump EEPROM\r\n",0
000130  20454550
000134  524f4d0d
000138  0a00    
00013a  00                DCB      0
00013b  00                DCB      0
                  |L2.316|
00013c  30782532          DCB      "0x%2X,",0
000140  582c00  
000143  00                DCB      0

                          AREA ||i.I2C1_IRQHandler||, CODE, READONLY, ALIGN=2

                  I2C1_IRQHandler PROC
;;;96     
;;;97     void I2Cx_Master_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;98     {
;;;99         uint32_t u32Status;
;;;100    
;;;101        u32Status = I2C_GET_STATUS(MASTER_I2C);
000002  4908              LDR      r1,|L3.36|
000004  68c8              LDR      r0,[r1,#0xc]
;;;102    
;;;103        if (I2C_GET_TIMEOUT_FLAG(MASTER_I2C))
000006  694a              LDR      r2,[r1,#0x14]
000008  43d2              MVNS     r2,r2
00000a  07d2              LSLS     r2,r2,#31
00000c  d006              BEQ      |L3.28|
;;;104        {
;;;105            /* Clear I2C Timeout Flag */
;;;106            I2C_ClearTimeoutFlag(MASTER_I2C);                   
;;;107        }    
;;;108        else
;;;109        {
;;;110            if (I2Cx_Master_HandlerFn != NULL)
00000e  4906              LDR      r1,|L3.40|
000010  694a              LDR      r2,[r1,#0x14]  ; I2Cx_Master_HandlerFn
000012  2a00              CMP      r2,#0
000014  d001              BEQ      |L3.26|
;;;111                I2Cx_Master_HandlerFn(u32Status);
000016  6949              LDR      r1,[r1,#0x14]  ; I2Cx_Master_HandlerFn
000018  4788              BLX      r1
                  |L3.26|
;;;112        }
;;;113    }
00001a  bd10              POP      {r4,pc}
                  |L3.28|
00001c  4608              MOV      r0,r1                 ;106
00001e  f7fffffe          BL       I2C_ClearTimeoutFlag
000022  bd10              POP      {r4,pc}
;;;114    
                          ENDP

                  |L3.36|
                          DCD      0x40081000
                  |L3.40|
                          DCD      ||.data||

                          AREA ||i.I2C1_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  I2C1_Init PROC
;;;309    
;;;310    void I2C1_Init(void)	//PB1 : SCL , PB0 : SDA
000000  b510              PUSH     {r4,lr}
;;;311    {
;;;312        SYS_ResetModule(I2C1_RST);
000002  480e              LDR      r0,|L4.60|
000004  f7fffffe          BL       SYS_ResetModule
;;;313    
;;;314        /* Open I2C module and set bus clock */
;;;315        I2C_Open(MASTER_I2C, 100000);
000008  4c0e              LDR      r4,|L4.68|
00000a  490d              LDR      r1,|L4.64|
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       I2C_Open
;;;316    
;;;317        I2C_SetSlaveAddr(MASTER_I2C, 0, EEPROM_SLAVE_ADDR, 0);   /* Slave Address : 1101011b */
000012  2300              MOVS     r3,#0
000014  22a0              MOVS     r2,#0xa0
000016  4619              MOV      r1,r3
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       I2C_SetSlaveAddr
;;;318    
;;;319        /* Get I2C1 Bus Clock */
;;;320        printf("I2C clock %d Hz\n", I2C_GetBusClockFreq(MASTER_I2C));
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       I2C_GetBusClockFreq
000024  4601              MOV      r1,r0
000026  a008              ADR      r0,|L4.72|
000028  f7fffffe          BL       __2printf
;;;321    
;;;322        I2C_EnableInt(MASTER_I2C);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       I2C_EnableInt
000032  2001              MOVS     r0,#1
000034  4909              LDR      r1,|L4.92|
000036  04c0              LSLS     r0,r0,#19
000038  6008              STR      r0,[r1,#0]
;;;323        NVIC_EnableIRQ(MASTER_I2C_IRQn);
;;;324    	
;;;325    }
00003a  bd10              POP      {r4,pc}
;;;326    
                          ENDP

                  |L4.60|
                          DCD      0x04000009
                  |L4.64|
                          DCD      0x000186a0
                  |L4.68|
                          DCD      0x40081000
                  |L4.72|
000048  49324320          DCB      "I2C clock %d Hz\n",0
00004c  636c6f63
000050  6b202564
000054  20487a0a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L4.92|
                          DCD      0xe000e100

                          AREA ||i.I2Cx_MasterRx_multi||, CODE, READONLY, ALIGN=2

                  I2Cx_MasterRx_multi PROC
;;;114    
;;;115    void I2Cx_MasterRx_multi(uint32_t u32Status)
000000  b5f8              PUSH     {r3-r7,lr}
;;;116    {
;;;117        if(u32Status == MASTER_START_TRANSMIT) //0x08                       	/* START has been transmitted and prepare SLA+W */
;;;118        {
;;;119            I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | I2C_WR));    				/* Write SLA+W to Register I2CDAT */
;;;120            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
000002  243c              MOVS     r4,#0x3c
000004  4e2a              LDR      r6,|L5.176|
000006  4d2b              LDR      r5,|L5.180|
000008  2808              CMP      r0,#8                 ;117
00000a  d019              BEQ      |L5.64|
;;;121    
;;;122    		I2Cx_Master_LOG(u32Status);
;;;123        }
;;;124        else if(u32Status == MASTER_TRANSMIT_ADDRESS_ACK) //0x18        			/* SLA+W has been transmitted and ACK has been received */
00000c  2818              CMP      r0,#0x18
00000e  d01a              BEQ      |L5.70|
;;;125        {
;;;126            I2C_SET_DATA(MASTER_I2C, g_au8Reg);
;;;127            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;128    		
;;;129    		I2Cx_Master_LOG(u32Status);
;;;130        }
;;;131        else if(u32Status == MASTER_TRANSMIT_ADDRESS_NACK) //0x20            	/* SLA+W has been transmitted and NACK has been received */
000010  2820              CMP      r0,#0x20
000012  d01d              BEQ      |L5.80|
;;;132        {
;;;133            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA | I2C_CTL_STO);
;;;134    
;;;135    //        I2C_STOP(MASTER_I2C);
;;;136    //        I2C_START(MASTER_I2C);
;;;137    		
;;;138    		I2Cx_Master_LOG(u32Status);
;;;139        }
;;;140        else if(u32Status == MASTER_TRANSMIT_DATA_ACK) //0x28                  	/* DATA has been transmitted and ACK has been received */
;;;141        {
;;;142            if (rawlenth > 0)
;;;143    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA);				//repeat start
;;;144    		else
;;;145    		{
;;;146    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;147    			g_u8EndFlag = 1;
000014  2701              MOVS     r7,#1
000016  2828              CMP      r0,#0x28              ;140
000018  d01e              BEQ      |L5.88|
;;;148    		}
;;;149    		
;;;150    		I2Cx_Master_LOG(u32Status);
;;;151        }
;;;152        else if(u32Status == MASTER_REPEAT_START) //0x10                  		/* Repeat START has been transmitted and prepare SLA+R */
00001a  2810              CMP      r0,#0x10
00001c  d029              BEQ      |L5.114|
;;;153        {
;;;154            I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | I2C_RD));   		/* Write SLA+R to Register I2CDAT */
;;;155            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;156    		
;;;157    		I2Cx_Master_LOG(u32Status);
;;;158        }
;;;159        else if(u32Status == MASTER_RECEIVE_ADDRESS_ACK) //0x40                	/* SLA+R has been transmitted and ACK has been received */
00001e  2840              CMP      r0,#0x40
000020  d02b              BEQ      |L5.122|
;;;160        {
;;;161    		if (rawlenth > 1)
;;;162    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;163    		else
;;;164    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;165    
;;;166    		I2Cx_Master_LOG(u32Status);
;;;167        }
;;;168    	else if(u32Status == MASTER_RECEIVE_DATA_ACK) //0x50                 	/* DATA has been received and ACK has been returned */
000022  2850              CMP      r0,#0x50
000024  d02d              BEQ      |L5.130|
;;;169        {
;;;170            g_au8Buffer[g_u8DataLen_m++] = (unsigned char) I2C_GetData(MASTER_I2C);
;;;171            if (g_u8DataLen_m < (rawlenth-1))
;;;172    		{
;;;173    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_AA);
;;;174    		}
;;;175    		else
;;;176    		{
;;;177    			I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;178    		}
;;;179    		
;;;180    		I2Cx_Master_LOG(u32Status);
;;;181        }
;;;182        else if(u32Status == MASTER_RECEIVE_DATA_NACK) //0x58                  	/* DATA has been received and NACK has been returned */
000026  2858              CMP      r0,#0x58
000028  d111              BNE      |L5.78|
;;;183        {
;;;184            g_au8Buffer[g_u8DataLen_m++] = (unsigned char) I2C_GetData(MASTER_I2C);
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       I2C_GetData
000030  4601              MOV      r1,r0
000032  7930              LDRB     r0,[r6,#4]  ; g_u8DataLen_m
000034  69b2              LDR      r2,[r6,#0x18]  ; g_au8Buffer
000036  1812              ADDS     r2,r2,r0
000038  1c40              ADDS     r0,r0,#1
00003a  7130              STRB     r0,[r6,#4]
00003c  7011              STRB     r1,[r2,#0]
;;;185            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;186            g_u8EndFlag = 1;
;;;187    
;;;188    		
;;;189    		I2Cx_Master_LOG(u32Status);
00003e  e012              B        |L5.102|
                  |L5.64|
000040  78f0              LDRB     r0,[r6,#3]            ;119  ; g_u8DeviceAddr_m
000042  0040              LSLS     r0,r0,#1              ;119
000044  e000              B        |L5.72|
                  |L5.70|
000046  79b0              LDRB     r0,[r6,#6]            ;126  ; g_au8Reg
                  |L5.72|
000048  60a8              STR      r0,[r5,#8]            ;119
00004a  e02d              B        |L5.168|
                  |L5.76|
00004c  6028              STR      r0,[r5,#0]            ;120
                  |L5.78|
;;;190        }
;;;191        else
;;;192        {
;;;193    		#if defined (DEBUG_LOG_MASTER_LV1)
;;;194            /* TO DO */
;;;195            printf("I2Cx_MasterRx_multi Status 0x%x is NOT processed\n", u32Status);
;;;196    		#endif
;;;197        }
;;;198    }
00004e  bdf8              POP      {r3-r7,pc}
                  |L5.80|
000050  6828              LDR      r0,[r5,#0]            ;133
000052  43a0              BICS     r0,r0,r4              ;133
000054  3038              ADDS     r0,r0,#0x38           ;133
000056  e7f9              B        |L5.76|
                  |L5.88|
000058  7970              LDRB     r0,[r6,#5]            ;142  ; rawlenth
00005a  2800              CMP      r0,#0                 ;142
00005c  d003              BEQ      |L5.102|
00005e  6828              LDR      r0,[r5,#0]            ;143
000060  43a0              BICS     r0,r0,r4              ;143
000062  3028              ADDS     r0,r0,#0x28           ;143
000064  e7f2              B        |L5.76|
                  |L5.102|
000066  6828              LDR      r0,[r5,#0]            ;146
000068  43a0              BICS     r0,r0,r4              ;146
00006a  3018              ADDS     r0,r0,#0x18           ;146
00006c  6028              STR      r0,[r5,#0]            ;146
00006e  7037              STRB     r7,[r6,#0]            ;147
000070  bdf8              POP      {r3-r7,pc}
                  |L5.114|
000072  78f0              LDRB     r0,[r6,#3]            ;154  ; g_u8DeviceAddr_m
000074  0040              LSLS     r0,r0,#1              ;154
000076  1c40              ADDS     r0,r0,#1              ;154
000078  e7e6              B        |L5.72|
                  |L5.122|
00007a  7970              LDRB     r0,[r6,#5]            ;161  ; rawlenth
00007c  2801              CMP      r0,#1                 ;161
00007e  d80f              BHI      |L5.160|
000080  e012              B        |L5.168|
                  |L5.130|
000082  4628              MOV      r0,r5                 ;170
000084  f7fffffe          BL       I2C_GetData
000088  4601              MOV      r1,r0                 ;170
00008a  7930              LDRB     r0,[r6,#4]            ;170  ; g_u8DataLen_m
00008c  69b2              LDR      r2,[r6,#0x18]         ;170  ; g_au8Buffer
00008e  1812              ADDS     r2,r2,r0              ;170
000090  1c40              ADDS     r0,r0,#1              ;170
000092  7130              STRB     r0,[r6,#4]            ;170
000094  7011              STRB     r1,[r2,#0]            ;170
000096  7931              LDRB     r1,[r6,#4]            ;171  ; g_u8DataLen_m
000098  7970              LDRB     r0,[r6,#5]            ;171  ; rawlenth
00009a  1e40              SUBS     r0,r0,#1              ;171
00009c  4281              CMP      r1,r0                 ;171
00009e  da03              BGE      |L5.168|
                  |L5.160|
0000a0  6828              LDR      r0,[r5,#0]            ;173
0000a2  43a0              BICS     r0,r0,r4              ;173
0000a4  300c              ADDS     r0,r0,#0xc            ;173
0000a6  e7d1              B        |L5.76|
                  |L5.168|
0000a8  6828              LDR      r0,[r5,#0]            ;177
0000aa  43a0              BICS     r0,r0,r4              ;177
0000ac  3008              ADDS     r0,r0,#8              ;177
0000ae  e7cd              B        |L5.76|
;;;199    
                          ENDP

                  |L5.176|
                          DCD      ||.data||
                  |L5.180|
                          DCD      0x40081000

                          AREA ||i.I2Cx_MasterTx_multi||, CODE, READONLY, ALIGN=2

                  I2Cx_MasterTx_multi PROC
;;;199    
;;;200    void I2Cx_MasterTx_multi(uint32_t u32Status)
000000  b510              PUSH     {r4,lr}
;;;201    {
;;;202        if(u32Status == MASTER_START_TRANSMIT)  //0x08                     	/* START has been transmitted */
;;;203        {
;;;204            I2C_SET_DATA(MASTER_I2C, ((g_u8DeviceAddr_m << 1) | I2C_WR));    			/* Write SLA+W to Register I2CDAT */
000002  491d              LDR      r1,|L6.120|
;;;205            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
000004  223c              MOVS     r2,#0x3c
000006  4b1d              LDR      r3,|L6.124|
000008  2808              CMP      r0,#8                 ;202
00000a  d011              BEQ      |L6.48|
;;;206    
;;;207    		I2Cx_Master_LOG(u32Status);
;;;208    		
;;;209        }
;;;210        else if(u32Status == MASTER_TRANSMIT_ADDRESS_ACK)  //0x18           	/* SLA+W has been transmitted and ACK has been received */
00000c  2818              CMP      r0,#0x18
00000e  d012              BEQ      |L6.54|
;;;211        {
;;;212            I2C_SET_DATA(MASTER_I2C, g_au8Reg);
;;;213            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;214    		
;;;215    		I2Cx_Master_LOG(u32Status);	
;;;216        }
;;;217        else if(u32Status == MASTER_TRANSMIT_ADDRESS_NACK) //0x20           /* SLA+W has been transmitted and NACK has been received */
000010  2820              CMP      r0,#0x20
000012  d017              BEQ      |L6.68|
;;;218        {
;;;219            I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STA | I2C_CTL_STO);
;;;220    
;;;221    //        I2C_STOP(MASTER_I2C);
;;;222    //        I2C_START(MASTER_I2C);
;;;223    
;;;224    		I2Cx_Master_LOG(u32Status);	
;;;225        }
;;;226        else if(u32Status == MASTER_TRANSMIT_DATA_ACK) //0x28              	/* DATA has been transmitted and ACK has been received */
000014  2828              CMP      r0,#0x28
000016  d019              BEQ      |L6.76|
;;;227        {
;;;228            if(g_u8DataLen_m < rawlenth)
;;;229            {
;;;230                I2C_SET_DATA(MASTER_I2C, g_au8Buffer[g_u8DataLen_m++]);
;;;231                I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI);
;;;232            }
;;;233            else
;;;234            {
;;;235                I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI | I2C_CTL_STO);
;;;236                g_u8EndFlag = 1;
;;;237            }
;;;238    
;;;239    		I2Cx_Master_LOG(u32Status);		
;;;240        }
;;;241        else if(u32Status == MASTER_ARBITRATION_LOST) //0x38
000018  2838              CMP      r0,#0x38
00001a  d029              BEQ      |L6.112|
;;;242        {
;;;243    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA_SI_AA);
;;;244    
;;;245    		I2Cx_Master_LOG(u32Status);		
;;;246        }
;;;247        else if(u32Status == BUS_ERROR) //0x00
00001c  2800              CMP      r0,#0
00001e  d110              BNE      |L6.66|
;;;248        {
;;;249    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STO_SI_AA);
000020  6808              LDR      r0,[r1,#0]
000022  4390              BICS     r0,r0,r2
000024  301c              ADDS     r0,r0,#0x1c
000026  6008              STR      r0,[r1,#0]
;;;250    		I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_SI_AA);
000028  6808              LDR      r0,[r1,#0]
00002a  4390              BICS     r0,r0,r2
00002c  300c              ADDS     r0,r0,#0xc
;;;251    		
;;;252    		I2Cx_Master_LOG(u32Status);		
00002e  e007              B        |L6.64|
                  |L6.48|
000030  78d8              LDRB     r0,[r3,#3]            ;204  ; g_u8DeviceAddr_m
000032  0040              LSLS     r0,r0,#1              ;204
000034  e000              B        |L6.56|
                  |L6.54|
000036  7998              LDRB     r0,[r3,#6]            ;212  ; g_au8Reg
                  |L6.56|
000038  6088              STR      r0,[r1,#8]            ;204
00003a  6808              LDR      r0,[r1,#0]            ;205
00003c  4390              BICS     r0,r0,r2              ;205
00003e  3008              ADDS     r0,r0,#8              ;205
                  |L6.64|
000040  6008              STR      r0,[r1,#0]            ;205
                  |L6.66|
;;;253        }		
;;;254        else
;;;255        {
;;;256    		#if defined (DEBUG_LOG_MASTER_LV1)
;;;257            /* TO DO */
;;;258            printf("I2Cx_MasterTx_multi Status 0x%x is NOT processed\n", u32Status);
;;;259    		#endif
;;;260        }
;;;261    }
000042  bd10              POP      {r4,pc}
                  |L6.68|
000044  6808              LDR      r0,[r1,#0]            ;219
000046  4390              BICS     r0,r0,r2              ;219
000048  3038              ADDS     r0,r0,#0x38           ;219
00004a  e7f9              B        |L6.64|
                  |L6.76|
00004c  7918              LDRB     r0,[r3,#4]            ;228  ; g_u8DataLen_m
00004e  795c              LDRB     r4,[r3,#5]            ;228  ; rawlenth
000050  42a0              CMP      r0,r4                 ;228
000052  d206              BCS      |L6.98|
000054  7918              LDRB     r0,[r3,#4]            ;230  ; g_u8DataLen_m
000056  699c              LDR      r4,[r3,#0x18]         ;230  ; g_au8Buffer
000058  1824              ADDS     r4,r4,r0              ;230
00005a  1c40              ADDS     r0,r0,#1              ;230
00005c  7118              STRB     r0,[r3,#4]            ;230
00005e  7820              LDRB     r0,[r4,#0]            ;230
000060  e7ea              B        |L6.56|
                  |L6.98|
000062  6808              LDR      r0,[r1,#0]            ;235
000064  4390              BICS     r0,r0,r2              ;235
000066  3018              ADDS     r0,r0,#0x18           ;235
000068  6008              STR      r0,[r1,#0]            ;235
00006a  2001              MOVS     r0,#1                 ;236
00006c  7018              STRB     r0,[r3,#0]            ;236
00006e  bd10              POP      {r4,pc}
                  |L6.112|
000070  6808              LDR      r0,[r1,#0]            ;243
000072  4390              BICS     r0,r0,r2              ;243
000074  302c              ADDS     r0,r0,#0x2c           ;243
000076  e7e3              B        |L6.64|
;;;262    
                          ENDP

                  |L6.120|
                          DCD      0x40081000
                  |L6.124|
                          DCD      ||.data||

                          AREA ||i.I2Cx_Master_LOG||, CODE, READONLY, ALIGN=1

                  I2Cx_Master_LOG PROC
;;;88     
;;;89     void I2Cx_Master_LOG(uint32_t u32Status)
000000  4770              BX       lr
;;;90     {
;;;91     	#if defined (DEBUG_LOG_MASTER_LV1)
;;;92         printf("%s  : 0x%2x \r\n", __FUNCTION__ , u32Status);
;;;93     	#endif
;;;94     }
;;;95     
                          ENDP


                          AREA ||i.I2Cx_ReadMultiFromSlaveIRQ||, CODE, READONLY, ALIGN=2

                  I2Cx_ReadMultiFromSlaveIRQ PROC
;;;285    
;;;286    void I2Cx_ReadMultiFromSlaveIRQ(uint8_t address,uint8_t reg,uint8_t *data,uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;287    { 
;;;288    	g_u8DeviceAddr_m = address;
000002  4c0a              LDR      r4,|L8.44|
000004  70e0              STRB     r0,[r4,#3]
;;;289    	rawlenth = len;
000006  7163              STRB     r3,[r4,#5]
;;;290    	g_au8Reg = reg ;
000008  71a1              STRB     r1,[r4,#6]
;;;291    	g_au8Buffer = data;
;;;292    
;;;293    	g_u8EndFlag = 0;
00000a  2000              MOVS     r0,#0
00000c  61a2              STR      r2,[r4,#0x18]  ; g_au8Buffer
00000e  7020              STRB     r0,[r4,#0]
;;;294    	g_u8DataLen_m = 0;
000010  7120              STRB     r0,[r4,#4]
;;;295    
;;;296    	/* I2C function to read data from slave */
;;;297    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterRx_multi;
000012  4807              LDR      r0,|L8.48|
000014  6160              STR      r0,[r4,#0x14]  ; I2Cx_Master_HandlerFn
;;;298    
;;;299    //	printf("I2Cx_MasterRx_multi finish\r\n");
;;;300    	
;;;301    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4907              LDR      r1,|L8.52|
000018  6808              LDR      r0,[r1,#0]
00001a  223c              MOVS     r2,#0x3c
00001c  4390              BICS     r0,r0,r2
00001e  3020              ADDS     r0,r0,#0x20
000020  6008              STR      r0,[r1,#0]
                  |L8.34|
;;;302    
;;;303    	/* Wait I2C Rx Finish */
;;;304    	while(g_u8EndFlag == 0);
000022  7820              LDRB     r0,[r4,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L8.34|
;;;305    	
;;;306    }
000028  bd10              POP      {r4,pc}
;;;307    
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      ||.data||
                  |L8.48|
                          DCD      I2Cx_MasterRx_multi
                  |L8.52|
                          DCD      0x40081000

                          AREA ||i.I2Cx_WriteMultiToSlaveIRQ||, CODE, READONLY, ALIGN=2

                  I2Cx_WriteMultiToSlaveIRQ PROC
;;;262    
;;;263    void I2Cx_WriteMultiToSlaveIRQ(uint8_t address,uint8_t reg,uint8_t *data,uint16_t len)
000000  b510              PUSH     {r4,lr}
;;;264    {		
;;;265    	g_u8DeviceAddr_m = address;
000002  4c0a              LDR      r4,|L9.44|
000004  70e0              STRB     r0,[r4,#3]
;;;266    	rawlenth = len;
000006  7163              STRB     r3,[r4,#5]
;;;267    	g_au8Reg = reg;
000008  71a1              STRB     r1,[r4,#6]
;;;268    	g_au8Buffer = data;
;;;269    
;;;270    	g_u8DataLen_m = 0;
00000a  2100              MOVS     r1,#0
00000c  61a2              STR      r2,[r4,#0x18]  ; g_au8Buffer
00000e  7121              STRB     r1,[r4,#4]
;;;271    	g_u8EndFlag = 0;
000010  7021              STRB     r1,[r4,#0]
;;;272    
;;;273    	/* I2C function to write data to slave */
;;;274    	I2Cx_Master_HandlerFn = (I2C_FUNC)I2Cx_MasterTx_multi;
000012  4807              LDR      r0,|L9.48|
000014  6160              STR      r0,[r4,#0x14]  ; I2Cx_Master_HandlerFn
;;;275    
;;;276    //	printf("I2Cx_MasterTx_multi finish\r\n");
;;;277    
;;;278    	/* I2C as master sends START signal */
;;;279    	I2C_SET_CONTROL_REG(MASTER_I2C, I2C_CTL_STA);
000016  4807              LDR      r0,|L9.52|
000018  6802              LDR      r2,[r0,#0]
00001a  233c              MOVS     r3,#0x3c
00001c  439a              BICS     r2,r2,r3
00001e  3220              ADDS     r2,r2,#0x20
000020  6002              STR      r2,[r0,#0]
                  |L9.34|
;;;280    
;;;281    	/* Wait I2C Tx Finish */
;;;282    	while(g_u8EndFlag == 0);
000022  7820              LDRB     r0,[r4,#0]  ; g_u8EndFlag
000024  2800              CMP      r0,#0
000026  d0fc              BEQ      |L9.34|
;;;283    	g_u8EndFlag = 0;
000028  7021              STRB     r1,[r4,#0]
;;;284    }
00002a  bd10              POP      {r4,pc}
;;;285    
                          ENDP

                  |L9.44|
                          DCD      ||.data||
                  |L9.48|
                          DCD      I2Cx_MasterTx_multi
                  |L9.52|
                          DCD      0x40081000

                          AREA ||i.NVIC_SystemReset||, CODE, READONLY, ALIGN=2

                  NVIC_SystemReset PROC
;;;729     */
;;;730    __STATIC_INLINE void NVIC_SystemReset(void)
000000  f3bf8f4f          DSB      
;;;731    {
;;;732      __DSB();                                                          /* Ensure all outstanding memory accesses included
;;;733                                                                           buffered write are completed before reset */
;;;734      SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
000004  4904              LDR      r1,|L10.24|
000006  4803              LDR      r0,|L10.20|
000008  60c8              STR      r0,[r1,#0xc]
;;;735                     SCB_AIRCR_SYSRESETREQ_Msk);
;;;736      __DSB();                                                          /* Ensure completion of memory access */
00000a  f3bf8f4f          DSB      
                  |L10.14|
;;;737    
;;;738      for(;;)                                                           /* wait until reset */
;;;739      {
;;;740        __NOP();
00000e  bf00              NOP      
000010  e7fd              B        |L10.14|
;;;741      }
;;;742    }
;;;743    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      0x05fa0004
                  |L10.24|
                          DCD      0xe000ed00

                          AREA ||i.SYS_Init||, CODE, READONLY, ALIGN=2

                  SYS_Init PROC
;;;592    
;;;593    void SYS_Init(void)
000000  b570              PUSH     {r4-r6,lr}
000002  2059              MOVS     r0,#0x59
000004  4c21              LDR      r4,|L11.140|
000006  2216              MOVS     r2,#0x16
000008  2188              MOVS     r1,#0x88
                  |L11.10|
00000a  6020              STR      r0,[r4,#0]
00000c  6022              STR      r2,[r4,#0]
00000e  6021              STR      r1,[r4,#0]
000010  6823              LDR      r3,[r4,#0]
000012  2b00              CMP      r3,#0
000014  d0f9              BEQ      |L11.10|
;;;594    {
;;;595        /* Unlock protected registers */
;;;596        SYS_UnlockReg();
;;;597    
;;;598        /* Enable HIRC clock (Internal RC 48MHz) */
;;;599        CLK_EnableXtalRC(CLK_PWRCTL_HIRCEN_Msk);
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       CLK_EnableXtalRC
;;;600    //    CLK_EnableXtalRC(CLK_PWRCTL_HXTEN_Msk);
;;;601    	
;;;602        /* Wait for HIRC clock ready */
;;;603        CLK_WaitClockReady(CLK_STATUS_HIRCSTB_Msk);
00001c  2010              MOVS     r0,#0x10
00001e  f7fffffe          BL       CLK_WaitClockReady
;;;604    //    CLK_WaitClockReady(CLK_STATUS_HXTSTB_Msk);
;;;605    
;;;606        CLK_EnableXtalRC(CLK_PWRCTL_LIRCEN_Msk);
000022  2008              MOVS     r0,#8
000024  f7fffffe          BL       CLK_EnableXtalRC
;;;607    
;;;608        /* Waiting for LIRC clock ready */
;;;609        CLK_WaitClockReady(CLK_STATUS_LIRCSTB_Msk);
000028  2008              MOVS     r0,#8
00002a  f7fffffe          BL       CLK_WaitClockReady
;;;610    
;;;611    
;;;612        /* Select HCLK clock source as HIRC and HCLK source divider as 1 */
;;;613        CLK_SetHCLK(CLK_CLKSEL0_HCLKSEL_HIRC, CLK_CLKDIV0_HCLK(1));
00002e  2100              MOVS     r1,#0
000030  2007              MOVS     r0,#7
000032  f7fffffe          BL       CLK_SetHCLK
;;;614    
;;;615        /* Enable UART0 clock */
;;;616        CLK_EnableModuleClock(UART0_MODULE);
000036  4d16              LDR      r5,|L11.144|
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       CLK_EnableModuleClock
;;;617        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART0SEL_PCLK0, CLK_CLKDIV0_UART0(1));
00003e  2101              MOVS     r1,#1
000040  2200              MOVS     r2,#0
000042  0689              LSLS     r1,r1,#26
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       CLK_SetModuleClock
;;;618    	
;;;619        CLK_EnableModuleClock(TMR3_MODULE);
00004a  4d12              LDR      r5,|L11.148|
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       CLK_EnableModuleClock
;;;620        CLK_SetModuleClock(TMR3_MODULE, CLK_CLKSEL1_TMR3SEL_PCLK1, 0);
000052  2101              MOVS     r1,#1
000054  2200              MOVS     r2,#0
000056  0549              LSLS     r1,r1,#21
000058  4628              MOV      r0,r5
00005a  f7fffffe          BL       CLK_SetModuleClock
;;;621    
;;;622        CLK_EnableModuleClock(I2C1_MODULE);
00005e  480b              LDR      r0,|L11.140|
000060  38f7              SUBS     r0,r0,#0xf7
000062  f7fffffe          BL       CLK_EnableModuleClock
;;;623    
;;;624        /* Update System Core Clock */
;;;625        SystemCoreClockUpdate();
000066  f7fffffe          BL       SystemCoreClockUpdate
;;;626    
;;;627        /* Set PB multi-function pins for UART0 RXD=PB.12 and TXD=PB.13 */
;;;628        SYS->GPB_MFPH = (SYS->GPB_MFPH & ~(SYS_GPB_MFPH_PB12MFP_Msk | SYS_GPB_MFPH_PB13MFP_Msk))    |       \
00006a  07a8              LSLS     r0,r5,#30
00006c  6bc1              LDR      r1,[r0,#0x3c]
00006e  22ff              MOVS     r2,#0xff
000070  0412              LSLS     r2,r2,#16
000072  4391              BICS     r1,r1,r2
000074  2233              MOVS     r2,#0x33
000076  0452              LSLS     r2,r2,#17
000078  1889              ADDS     r1,r1,r2
00007a  63c1              STR      r1,[r0,#0x3c]
;;;629                        (SYS_GPB_MFPH_PB12MFP_UART0_RXD | SYS_GPB_MFPH_PB13MFP_UART0_TXD);
;;;630    
;;;631        /* Set I2C1 multi-function pins */
;;;632        SYS->GPB_MFPL = (SYS->GPB_MFPL & ~(SYS_GPB_MFPL_PB0MFP_Msk | SYS_GPB_MFPL_PB1MFP_Msk )) |
00007c  6b81              LDR      r1,[r0,#0x38]
00007e  0a09              LSRS     r1,r1,#8
000080  0209              LSLS     r1,r1,#8
000082  3199              ADDS     r1,r1,#0x99
000084  6381              STR      r1,[r0,#0x38]
000086  2000              MOVS     r0,#0
000088  6020              STR      r0,[r4,#0]
;;;633                        (SYS_GPB_MFPL_PB0MFP_I2C1_SDA | SYS_GPB_MFPL_PB1MFP_I2C1_SCL);
;;;634    
;;;635        /* Lock protected registers */
;;;636        SYS_LockReg();
;;;637    }
00008a  bd70              POP      {r4-r6,pc}
;;;638    
                          ENDP

                  |L11.140|
                          DCD      0x40000100
                  |L11.144|
                          DCD      0x5f803d10
                  |L11.148|
                          DCD      0x5f400005

                          AREA ||i.TIMER3_Init||, CODE, READONLY, ALIGN=2

                  TIMER3_Init PROC
;;;481    
;;;482    void TIMER3_Init(void)
000000  b510              PUSH     {r4,lr}
;;;483    {
;;;484        TIMER_Open(TIMER3, TIMER_PERIODIC_MODE, 1000);
000002  4c0a              LDR      r4,|L12.44|
000004  227d              MOVS     r2,#0x7d
000006  2101              MOVS     r1,#1
000008  00d2              LSLS     r2,r2,#3
00000a  06c9              LSLS     r1,r1,#27
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       TIMER_Open
000012  6820              LDR      r0,[r4,#0]
000014  0621              LSLS     r1,r4,#24
000016  4308              ORRS     r0,r0,r1
000018  6020              STR      r0,[r4,#0]
00001a  1488              ASRS     r0,r1,#18
00001c  4904              LDR      r1,|L12.48|
00001e  6008              STR      r0,[r1,#0]
000020  6820              LDR      r0,[r4,#0]
000022  0589              LSLS     r1,r1,#22
000024  4308              ORRS     r0,r0,r1
000026  6020              STR      r0,[r4,#0]
;;;485        TIMER_EnableInt(TIMER3);
;;;486        NVIC_EnableIRQ(TMR3_IRQn);	
;;;487        TIMER_Start(TIMER3);
;;;488    }
000028  bd10              POP      {r4,pc}
;;;489    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      0x40051020
                  |L12.48|
                          DCD      0xe000e100

                          AREA ||i.TMR3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TMR3_IRQHandler PROC
;;;458    
;;;459    void TMR3_IRQHandler(void)
000000  b500              PUSH     {lr}
000002  480c              LDR      r0,|L13.52|
000004  6881              LDR      r1,[r0,#8]
000006  07c9              LSLS     r1,r1,#31
000008  0fc9              LSRS     r1,r1,#31
;;;460    {
00000a  d011              BEQ      |L13.48|
00000c  2201              MOVS     r2,#1
00000e  6082              STR      r2,[r0,#8]
;;;461    	static uint32_t LOG = 0;
;;;462    	static uint16_t CNT = 0;
;;;463    	
;;;464        if(TIMER_GetIntFlag(TIMER3) == 1)
;;;465        {
;;;466            TIMER_ClearIntFlag(TIMER3);
;;;467    
;;;468    		tick_counter();
000010  f7fffffe          BL       tick_counter
;;;469    
;;;470    		if (CNT++ >= 1000)
000014  4908              LDR      r1,|L13.56|
000016  8908              LDRH     r0,[r1,#8]  ; CNT
000018  1c43              ADDS     r3,r0,#1
00001a  810b              STRH     r3,[r1,#8]
00001c  237d              MOVS     r3,#0x7d
00001e  00db              LSLS     r3,r3,#3
000020  4298              CMP      r0,r3
000022  d305              BCC      |L13.48|
;;;471    		{		
;;;472    			CNT = 0;
000024  2000              MOVS     r0,#0
000026  8108              STRH     r0,[r1,#8]
;;;473    //        	printf("%s : %4d\r\n",__FUNCTION__,LOG++);
;;;474    			PB14 ^= 1;
000028  4804              LDR      r0,|L13.60|
00002a  6b81              LDR      r1,[r0,#0x38]
00002c  4051              EORS     r1,r1,r2
00002e  6381              STR      r1,[r0,#0x38]
                  |L13.48|
;;;475    
;;;476    		}
;;;477    
;;;478        }
;;;479    }
000030  bd00              POP      {pc}
;;;480    
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      0x40051020
                  |L13.56|
                          DCD      ||.data||
                  |L13.60|
                          DCD      0x40004840

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;550    
;;;551    void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;552    {	
;;;553    
;;;554        if(UART_GET_INT_FLAG(UART0, UART_INTSTS_RDAINT_Msk | UART_INTSTS_RXTOINT_Msk))     /* UART receive data available flag */
000002  4c0b              LDR      r4,|L14.48|
000004  69e0              LDR      r0,[r4,#0x1c]
000006  2111              MOVS     r1,#0x11
000008  0209              LSLS     r1,r1,#8
00000a  4208              TST      r0,r1
00000c  d102              BNE      |L14.20|
00000e  e004              B        |L14.26|
                  |L14.16|
;;;555        {
;;;556            while(UART_GET_RX_EMPTY(UART0) == 0)
;;;557            {
;;;558                UARTx_Process();
000010  f7fffffe          BL       UARTx_Process
                  |L14.20|
000014  69a1              LDR      r1,[r4,#0x18]         ;556
000016  0449              LSLS     r1,r1,#17             ;556
000018  d5fa              BPL      |L14.16|
                  |L14.26|
;;;559            }
;;;560        }
;;;561    
;;;562        if(UART0->FIFOSTS & (UART_FIFOSTS_BIF_Msk | UART_FIFOSTS_FEF_Msk | UART_FIFOSTS_PEF_Msk | UART_FIFOSTS_RXOVIF_Msk))
00001a  69a1              LDR      r1,[r4,#0x18]
00001c  4620              MOV      r0,r4
00001e  2271              MOVS     r2,#0x71
000020  4211              TST      r1,r2
000022  d003              BEQ      |L14.44|
;;;563        {
;;;564            UART_ClearIntFlag(UART0, (UART_INTSTS_RLSINT_Msk| UART_INTSTS_BUFERRINT_Msk));
000024  2109              MOVS     r1,#9
000026  0289              LSLS     r1,r1,#10
000028  f7fffffe          BL       UART_ClearIntFlag
                  |L14.44|
;;;565        }
;;;566    }
00002c  bd10              POP      {r4,pc}
;;;567    
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      0x40070000

                          AREA ||i.UART0_Init||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  UART0_Init PROC
;;;567    
;;;568    void UART0_Init(void)
000000  b510              PUSH     {r4,lr}
;;;569    {
;;;570        SYS_ResetModule(UART0_RST);
000002  481e              LDR      r0,|L15.124|
000004  f7fffffe          BL       SYS_ResetModule
;;;571    
;;;572        /* Configure UART0 and set UART0 baud rate */
;;;573        UART_Open(UART0, 115200);
000008  4c1d              LDR      r4,|L15.128|
00000a  21e1              MOVS     r1,#0xe1
00000c  0249              LSLS     r1,r1,#9
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       UART_Open
;;;574    
;;;575    	/* Set UART receive time-out */
;;;576    	UART_SetTimeoutCnt(UART0, 20);
000014  2114              MOVS     r1,#0x14
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       UART_SetTimeoutCnt
;;;577    
;;;578    	UART0->FIFO &= ~UART_FIFO_RFITL_4BYTES;
00001c  68a0              LDR      r0,[r4,#8]
00001e  2110              MOVS     r1,#0x10
000020  4388              BICS     r0,r0,r1
000022  60a0              STR      r0,[r4,#8]
;;;579    	UART0->FIFO |= UART_FIFO_RFITL_8BYTES;
000024  68a0              LDR      r0,[r4,#8]
000026  2120              MOVS     r1,#0x20
000028  4308              ORRS     r0,r0,r1
00002a  60a0              STR      r0,[r4,#8]
;;;580    
;;;581    	/* Enable UART Interrupt - */
;;;582    	UART_ENABLE_INT(UART0, UART_INTEN_RDAIEN_Msk | UART_INTEN_TOCNTEN_Msk | UART_INTEN_RXTOIEN_Msk);
00002c  6860              LDR      r0,[r4,#4]
00002e  4915              LDR      r1,|L15.132|
000030  4308              ORRS     r0,r0,r1
000032  6060              STR      r0,[r4,#4]
000034  2001              MOVS     r0,#1
000036  4914              LDR      r1,|L15.136|
000038  0300              LSLS     r0,r0,#12
00003a  6008              STR      r0,[r1,#0]
;;;583    	
;;;584    	NVIC_EnableIRQ(UART02_IRQn);
;;;585    
;;;586    	printf("\r\nCLK_GetCPUFreq : %8d\r\n",CLK_GetCPUFreq());
00003c  f7fffffe          BL       CLK_GetCPUFreq
000040  4601              MOV      r1,r0
000042  a012              ADR      r0,|L15.140|
000044  f7fffffe          BL       __2printf
;;;587    	printf("CLK_GetHXTFreq : %8d\r\n",CLK_GetHXTFreq());
000048  f7fffffe          BL       CLK_GetHXTFreq
00004c  4601              MOV      r1,r0
00004e  a016              ADR      r0,|L15.168|
000050  f7fffffe          BL       __2printf
;;;588    	printf("CLK_GetLXTFreq : %8d\r\n",CLK_GetLXTFreq());	
000054  f7fffffe          BL       CLK_GetLXTFreq
000058  4601              MOV      r1,r0
00005a  a019              ADR      r0,|L15.192|
00005c  f7fffffe          BL       __2printf
;;;589    	printf("CLK_GetPCLK0Freq : %8d\r\n",CLK_GetPCLK0Freq());
000060  f7fffffe          BL       CLK_GetPCLK0Freq
000064  4601              MOV      r1,r0
000066  a01c              ADR      r0,|L15.216|
000068  f7fffffe          BL       __2printf
;;;590    	printf("CLK_GetPCLK1Freq : %8d\r\n",CLK_GetPCLK1Freq());	
00006c  f7fffffe          BL       CLK_GetPCLK1Freq
000070  4601              MOV      r1,r0
000072  a020              ADR      r0,|L15.244|
000074  f7fffffe          BL       __2printf
;;;591    }
000078  bd10              POP      {r4,pc}
;;;592    
                          ENDP

00007a  0000              DCW      0x0000
                  |L15.124|
                          DCD      0x04000010
                  |L15.128|
                          DCD      0x40070000
                  |L15.132|
                          DCD      0x00000811
                  |L15.136|
                          DCD      0xe000e100
                  |L15.140|
00008c  0d0a434c          DCB      "\r\nCLK_GetCPUFreq : %8d\r\n",0
000090  4b5f4765
000094  74435055
000098  46726571
00009c  203a2025
0000a0  38640d0a
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L15.168|
0000a8  434c4b5f          DCB      "CLK_GetHXTFreq : %8d\r\n",0
0000ac  47657448
0000b0  58544672
0000b4  6571203a
0000b8  20253864
0000bc  0d0a00  
0000bf  00                DCB      0
                  |L15.192|
0000c0  434c4b5f          DCB      "CLK_GetLXTFreq : %8d\r\n",0
0000c4  4765744c
0000c8  58544672
0000cc  6571203a
0000d0  20253864
0000d4  0d0a00  
0000d7  00                DCB      0
                  |L15.216|
0000d8  434c4b5f          DCB      "CLK_GetPCLK0Freq : %8d\r\n",0
0000dc  47657450
0000e0  434c4b30
0000e4  46726571
0000e8  203a2025
0000ec  38640d0a
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0
                  |L15.244|
0000f4  434c4b5f          DCB      "CLK_GetPCLK1Freq : %8d\r\n",0
0000f8  47657450
0000fc  434c4b31
000100  46726571
000104  203a2025
000108  38640d0a
00010c  00      
00010d  00                DCB      0
00010e  00                DCB      0
00010f  00                DCB      0

                          AREA ||i.UARTx_Process||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                  UARTx_Process PROC
;;;490    
;;;491    void UARTx_Process(void)
000000  b510              PUSH     {r4,lr}
;;;492    {
;;;493    	uint8_t res = 0;
;;;494    	
;;;495    	res = UART_READ(UART0);
000002  481c              LDR      r0,|L16.116|
000004  6800              LDR      r0,[r0,#0]
000006  b2c4              UXTB     r4,r0
;;;496    
;;;497    	printf("UARTx_Process = %c\r\n" ,res);
000008  4621              MOV      r1,r4
00000a  a01b              ADR      r0,|L16.120|
00000c  f7fffffe          BL       __2printf
;;;498    
;;;499    	if (res == 'x' || res == 'X')
000010  2c78              CMP      r4,#0x78
000012  d01c              BEQ      |L16.78|
000014  2c58              CMP      r4,#0x58
000016  d01a              BEQ      |L16.78|
;;;500    	{
;;;501    		NVIC_SystemReset();
;;;502    	}
;;;503    
;;;504    	if (res > 0x7F)
000018  2c7f              CMP      r4,#0x7f
00001a  d903              BLS      |L16.36|
;;;505    	{
;;;506    		printf("invalid command\r\n");
00001c  a01c              ADR      r0,|L16.144|
00001e  f7fffffe          BL       __2printf
                  |L16.34|
;;;507    	}
;;;508    	else
;;;509    	{
;;;510    		switch(res)
;;;511    		{
;;;512    			case '1' :
;;;513    				set_flag(flag_Dump , ENABLE);
;;;514    
;;;515    				break;
;;;516    
;;;517    			case '2': 
;;;518    				set_flag(flag_WriteAddr , ENABLE);
;;;519    			
;;;520    				break;
;;;521    
;;;522    			case '3': 
;;;523    				set_flag(flag_WriteData , ENABLE);			
;;;524    		
;;;525    				break;			
;;;526    
;;;527    			case '4': 
;;;528    				set_flag(flag_WriteData1 , ENABLE);			
;;;529    		
;;;530    				break;	
;;;531    
;;;532    			case '5': 
;;;533    				set_flag(flag_WriteData2 , ENABLE);			
;;;534    		
;;;535    				break;	
;;;536    
;;;537    
;;;538    			case '0' : 
;;;539    				set_flag(flag_Erase , ENABLE);
;;;540    
;;;541    				break;
;;;542    		
;;;543    			case 'Z':
;;;544    			case 'z':				
;;;545    				NVIC_SystemReset();
;;;546    				break;				
;;;547    		}
;;;548    	}
;;;549    }
000022  bd10              POP      {r4,pc}
                  |L16.36|
000024  481f              LDR      r0,|L16.164|
000026  2c34              CMP      r4,#0x34              ;510
000028  d01b              BEQ      |L16.98|
00002a  dc0a              BGT      |L16.66|
00002c  2c30              CMP      r4,#0x30              ;510
00002e  d01e              BEQ      |L16.110|
000030  2c31              CMP      r4,#0x31              ;510
000032  d00e              BEQ      |L16.82|
000034  2c32              CMP      r4,#0x32              ;510
000036  d00f              BEQ      |L16.88|
000038  2c33              CMP      r4,#0x33              ;510
00003a  d1f2              BNE      |L16.34|
00003c  68c1              LDR      r1,[r0,#0xc]          ;523  ; BitFlag
00003e  2210              MOVS     r2,#0x10              ;523
000040  e00c              B        |L16.92|
                  |L16.66|
000042  2c35              CMP      r4,#0x35              ;510
000044  d010              BEQ      |L16.104|
000046  2c5a              CMP      r4,#0x5a              ;510
000048  d001              BEQ      |L16.78|
00004a  2c7a              CMP      r4,#0x7a              ;510
00004c  d1e9              BNE      |L16.34|
                  |L16.78|
00004e  f7fffffe          BL       NVIC_SystemReset
                  |L16.82|
000052  68c1              LDR      r1,[r0,#0xc]          ;513  ; BitFlag
000054  2202              MOVS     r2,#2                 ;513
000056  e001              B        |L16.92|
                  |L16.88|
000058  68c1              LDR      r1,[r0,#0xc]          ;518  ; BitFlag
00005a  2208              MOVS     r2,#8                 ;518
                  |L16.92|
00005c  4311              ORRS     r1,r1,r2              ;513
00005e  60c1              STR      r1,[r0,#0xc]          ;513  ; BitFlag
000060  bd10              POP      {r4,pc}
                  |L16.98|
000062  68c1              LDR      r1,[r0,#0xc]          ;528  ; BitFlag
000064  2220              MOVS     r2,#0x20              ;528
000066  e7f9              B        |L16.92|
                  |L16.104|
000068  68c1              LDR      r1,[r0,#0xc]          ;533  ; BitFlag
00006a  2240              MOVS     r2,#0x40              ;533
00006c  e7f6              B        |L16.92|
                  |L16.110|
00006e  68c1              LDR      r1,[r0,#0xc]          ;539  ; BitFlag
000070  2201              MOVS     r2,#1                 ;539
000072  e7f3              B        |L16.92|
;;;550    
                          ENDP

                  |L16.116|
                          DCD      0x40070000
                  |L16.120|
000078  55415254          DCB      "UARTx_Process = %c\r\n",0
00007c  785f5072
000080  6f636573
000084  73203d20
000088  25630d0a
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0
                  |L16.144|
000090  696e7661          DCB      "invalid command\r\n",0
000094  6c696420
000098  636f6d6d
00009c  616e640d
0000a0  0a00    
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L16.164|
                          DCD      ||.data||

                          AREA ||i.convertDecToBin||, CODE, READONLY, ALIGN=2

                  convertDecToBin PROC
;;;57     
;;;58     void convertDecToBin(int n)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;59     {
000002  b082              SUB      sp,sp,#8
;;;60         int k = 0;
000004  2500              MOVS     r5,#0
;;;61         unsigned char *p = (unsigned char*)&n;
000006  a802              ADD      r0,sp,#8
;;;62         int val2 = 0;
;;;63         int i = 0;
;;;64         for(k = 0; k <= 1; k++)
;;;65         {
;;;66             val2 = *(p+k);
;;;67             for (i = 7; i >= 0; i--)
;;;68             {
;;;69                 if(val2 & (1 << i))
000008  2701              MOVS     r7,#1
00000a  9000              STR      r0,[sp,#0]
                  |L17.12|
00000c  9800              LDR      r0,[sp,#0]            ;66
00000e  2407              MOVS     r4,#7                 ;67
000010  5d46              LDRB     r6,[r0,r5]            ;66
                  |L17.18|
000012  4638              MOV      r0,r7
000014  40a0              LSLS     r0,r0,r4
000016  4230              TST      r0,r6
000018  d001              BEQ      |L17.30|
;;;70                     printf("1");
00001a  a007              ADR      r0,|L17.56|
00001c  e000              B        |L17.32|
                  |L17.30|
;;;71                 else
;;;72                     printf("0");
00001e  a007              ADR      r0,|L17.60|
                  |L17.32|
000020  f7fffffe          BL       __2printf
000024  1e64              SUBS     r4,r4,#1
000026  d5f4              BPL      |L17.18|
;;;73             }
;;;74             printf(" ");
000028  a005              ADR      r0,|L17.64|
00002a  f7fffffe          BL       __2printf
00002e  1c6d              ADDS     r5,r5,#1
000030  2d01              CMP      r5,#1                 ;64
000032  ddeb              BLE      |L17.12|
;;;75         }
;;;76     }
000034  bdfe              POP      {r1-r7,pc}
;;;77     
                          ENDP

000036  0000              DCW      0x0000
                  |L17.56|
000038  3100              DCB      "1",0
00003a  00                DCB      0
00003b  00                DCB      0
                  |L17.60|
00003c  3000              DCB      "0",0
00003e  00                DCB      0
00003f  00                DCB      0
                  |L17.64|
000040  2000              DCB      " ",0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.get_tick||, CODE, READONLY, ALIGN=2

                  get_tick PROC
;;;83     
;;;84     uint32_t get_tick(void)
000000  4801              LDR      r0,|L18.8|
;;;85     {
;;;86     	return (conter_tick);
000002  6900              LDR      r0,[r0,#0x10]  ; conter_tick
;;;87     }
000004  4770              BX       lr
;;;88     
                          ENDP

000006  0000              DCW      0x0000
                  |L18.8|
                          DCD      ||.data||

                          AREA ||i.main||, CODE, READONLY, ALIGN=2

                  main PROC
;;;646    
;;;647    int main()
000000  f7fffffe          BL       SYS_Init
;;;648    {
;;;649    
;;;650        SYS_Init();
;;;651    
;;;652        UART0_Init();
000004  f7fffffe          BL       UART0_Init
;;;653    
;;;654        GPIO_SetMode(PB, BIT14, GPIO_MODE_OUTPUT);
000008  2201              MOVS     r2,#1
00000a  0391              LSLS     r1,r2,#14
00000c  4805              LDR      r0,|L19.36|
00000e  f7fffffe          BL       GPIO_SetMode
;;;655    
;;;656    	I2C1_Init();
000012  f7fffffe          BL       I2C1_Init
;;;657    
;;;658    	TIMER3_Init();
000016  f7fffffe          BL       TIMER3_Init
;;;659    
;;;660    	EEPROM_TEST();
00001a  f7fffffe          BL       EEPROM_TEST
                  |L19.30|
;;;661    
;;;662        /* Got no where to go, just loop forever */
;;;663        while(1)
;;;664        {
;;;665    		EEPROM_Process();
00001e  f7fffffe          BL       EEPROM_Process
000022  e7fc              B        |L19.30|
;;;666    
;;;667        }
;;;668    }
;;;669    
                          ENDP

                  |L19.36|
                          DCD      0x40004040

                          AREA ||i.tick_counter||, CODE, READONLY, ALIGN=2

                  tick_counter PROC
;;;78     
;;;79     void tick_counter(void)
000000  4802              LDR      r0,|L20.12|
;;;80     {
;;;81     	conter_tick++;
000002  6901              LDR      r1,[r0,#0x10]  ; conter_tick
000004  1c49              ADDS     r1,r1,#1
000006  6101              STR      r1,[r0,#0x10]  ; conter_tick
;;;82     }
000008  4770              BX       lr
;;;83     
                          ENDP

00000a  0000              DCW      0x0000
                  |L20.12|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=2

                  g_u8EndFlag
000000  00                DCB      0x00
                  addr
000001  00                DCB      0x00
                  temp
000002  00                DCB      0x00
                  g_u8DeviceAddr_m
000003  00                DCB      0x00
                  g_u8DataLen_m
000004  00                DCB      0x00
                  rawlenth
000005  00                DCB      0x00
                  g_au8Reg
000006  0000              DCB      0x00,0x00
                  ||CNT||
000008  0000              DCW      0x0000
00000a  0000              DCB      0x00,0x00
                  BitFlag
                          DCD      0x00000000
                  conter_tick
                          DCD      0x00000000
                  I2Cx_Master_HandlerFn
                          DCD      0x00000000
                  g_au8Buffer
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\main.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REV16|
#line 388 "..\\..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
|__asm___6_main_c_BitFlag____REV16| PROC
#line 389

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_main_c_BitFlag____REVSH|
#line 402
|__asm___6_main_c_BitFlag____REVSH| PROC
#line 403

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

                  __ARM_use_no_argv EQU 0
